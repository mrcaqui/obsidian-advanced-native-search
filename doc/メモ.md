Obsidianのネイティブ検索の機能を拡張するようなObsidian pluginを開発しています。まずは以下コード確認して既存プロジェクトを理解して下さい。

```plugin.ts
// plugin.ts
import { App, Notice, Plugin, WorkspaceLeaf } from "obsidian";
import { QueryPromptModal } from "./ui";
import { runSearch, ParsedQuery, SearchOptions, MatchLog } from "./search";
import { ResultsView, VIEW_TYPE_ANS_RESULTS } from "./resultsView";

/**
 * Settings
 */
interface AnsSettings {
  defaultDisplayMode: "split" | "window";
}

const DEFAULT_SETTINGS: AnsSettings = {
  defaultDisplayMode: "split",
};

export default class AdvancedNativeSearchPlugin extends Plugin {
  settings: AnsSettings = { ...DEFAULT_SETTINGS };

  // Track result leaves to reuse/close.
  private splitLeaf: WorkspaceLeaf | null = null;
  private windowLeaf: WorkspaceLeaf | null = null;

  // Last search payload (used when toggling views).
  private lastResults: MatchLog[] = [];
  private lastCaseSensitive = false;
  private lastSummary: { matchedFiles: number; totalLineHits: number; timeMs: number } | null = null;

  async onload() {
    await this.loadSettings();

    console.log("Loading Advanced Native-like Search plugin (ANS) with persistent results view");

    // Register the custom results view
    this.registerView(VIEW_TYPE_ANS_RESULTS, (leaf) => {
      const view = new ResultsView(leaf, this);
      return view;
    });

    // Command to open filter builder and run
    this.addCommand({
      id: "ans-open-native-like-search",
      name: "ANS: Run native-like search (filter builder)",
      callback: () => {
        new QueryPromptModal(this.app, (parsed, opts, uiState) =>
          this.handleSearchSubmit(parsed, opts, uiState)
        ).open();
      },
    });
  }

  onunload() {
    console.log("Unloading Advanced Native-like Search plugin");
    // Do not forcibly detach leaves; let the workspace manage persistence.
  }

  private async handleSearchSubmit(
    parsed: ParsedQuery,
    options: SearchOptions,
    uiState: { lineTerms: string[] }
  ) {
    const { matches, summary } = await runSearch(this.app, parsed, options, uiState);

    // Console summary
    console.log("[ANS] Accepted files:", summary.matchedFiles);
    console.log("[ANS] line: unique hit lines:", summary.totalLineHits);
    console.log("[ANS] Search time (ms):", summary.timeMs);
    console.log("[ANS] Sample results (max 10):", matches.slice(0, 10));
    console.log("[ANS] All results:", matches);

    // Breakdown logging (optional groups)
    if (parsed.filePatterns.length > 0) {
      console.groupCollapsed(`%c[ANS] Breakdown: file — criterion: file name matches each pattern (AND)`, "color:#9cf; font-weight:600;");
      console.log("Patterns:", parsed.filePatterns);
      for (const m of matches) {
        console.log(`${m.path}: file pattern matches=${m.filterHits?.file ?? 0}`);
      }
      console.groupEnd();
    }

    if (parsed.pathPatterns.length > 0) {
      console.groupCollapsed(`%c[ANS] Breakdown: path — criterion: path matches each pattern (AND)`, "color:#9cf; font-weight:600;");
      console.log("Patterns:", parsed.pathPatterns);
      for (const m of matches) {
        console.log(`${m.path}: path pattern matches=${m.filterHits?.path ?? 0}`);
      }
      console.groupEnd();
    }

    if (parsed.tagFilters.length > 0) {
      console.groupCollapsed(`%c[ANS] Breakdown: tag — criterion: tag set matches each filter (AND)`, "color:#9cf; font-weight:600;");
      console.log("Filters:", parsed.tagFilters);
      for (const m of matches) {
        console.log(`${m.path}: tag filter matches=${m.filterHits?.tag ?? 0}`);
      }
      console.groupEnd();
    }

    if (parsed.propertyFilters.length > 0) {
      console.groupCollapsed(`%c[ANS] Breakdown: property — criterion: frontmatter property matches (AND)`, "color:#9cf; font-weight:600;");
      console.log("Filters:", parsed.propertyFilters);
      for (const m of matches) {
        console.log(`${m.path}: property filter matches=${m.filterHits?.property ?? 0}`);
      }
      console.groupEnd();
    }

    if (parsed.headingPatterns.length > 0) {
      console.groupCollapsed(`%c[ANS] Breakdown: headings — criterion: heading text matches each pattern (AND)`, "color:#9cf; font-weight:600;");
      console.log("Patterns:", parsed.headingPatterns);
      for (const m of matches) {
        console.log(`${m.path}: headings pattern matches=${m.filterHits?.headings ?? 0}`);
      }
      console.groupEnd();
    }

    if (parsed.contentPatterns.length > 0) {
      console.groupCollapsed(`%c[ANS] Breakdown: content — criterion: body matches each pattern (AND)`, "color:#9cf; font-weight:600;");
      console.log("Patterns:", parsed.contentPatterns);
      for (const m of matches) {
        console.log(`${m.path}: content pattern matches=${m.filterHits?.content ?? 0}`);
      }
      console.groupEnd();
    }

    if (parsed.linePatterns.length > 0) {
      console.groupCollapsed(`%c[ANS] Breakdown: line — criterion: same line contains ALL terms (AND); unique hit lines`, "color:#9cf; font-weight:600;");
      for (const m of matches) {
        console.log(`${m.path}: line hit lines=${m.filterHits?.line ?? 0}`);
      }
      console.groupEnd();
    }

    if (parsed.globalQuery) {
      console.groupCollapsed(`%c[ANS] Breakdown: Global Query — criterion: selected targets across vault (Body/Name/Path/Frontmatter/Tags/Headings), OR per file`, "color:#9cf; font-weight:600;");
      for (const m of matches) {
        console.log(`${m.path}: Global Query total=${m.filterHits?.globalQuery ?? 0}`);
        console.log("Breakdown:", m.filterHits?.globalQueryBreakdown);
      }
      console.groupEnd();
    }

    // Persist last search payload for toggling
    this.lastResults = matches;
    this.lastCaseSensitive = options.caseSensitive;
    this.lastSummary = summary;

    // Show results in persistent view using preferred mode
    await this.showResults(matches, { caseSensitive: options.caseSensitive, displayMode: this.settings.defaultDisplayMode });

    new Notice(`ANS: Search finished. Files ${summary.matchedFiles}, line hits ${summary.totalLineHits}.`);
  }

  /**
   * Open or reuse the results view in the requested mode, update its data, and ensure the opposite mode is closed.
   */
  async showResults(
    results: MatchLog[],
    opts: { caseSensitive: boolean; displayMode: "split" | "window" }
  ) {
    if (opts.displayMode === "split") {
      // Close window if open
      if (this.windowLeaf) {
        try {
          this.windowLeaf.detach();
        } catch (e) {
          console.warn("[ANS] Failed to detach window leaf:", e);
        }
        this.windowLeaf = null;
      }

      const view = await this.ensureSplitResultsView();
      view.setData(results, {
        caseSensitive: opts.caseSensitive,
        displayMode: "split",
        summary: this.lastSummary ?? null,
      });
      this.settings.defaultDisplayMode = "split";
      await this.saveSettings();
    } else {
      // Close split if open
      if (this.splitLeaf) {
        try {
          this.splitLeaf.detach();
        } catch (e) {
          console.warn("[ANS] Failed to detach split leaf:", e);
        }
        this.splitLeaf = null;
      }

      const view = await this.ensureWindowResultsView();
      view.setData(results, {
        caseSensitive: opts.caseSensitive,
        displayMode: "window",
        summary: this.lastSummary ?? null,
      });
      this.settings.defaultDisplayMode = "window";
      await this.saveSettings();
    }
  }

  /**
   * Called by ResultsView header toggle buttons to switch modes immediately.
   */
  async requestSwitchDisplayMode(mode: "split" | "window") {
    if (!this.lastResults) return;
    if (this.settings.defaultDisplayMode === mode) {
      // Already in the requested mode; nothing to do.
      return;
    }
    await this.showResults(this.lastResults, {
      caseSensitive: this.lastCaseSensitive,
      displayMode: mode,
    });
  }

  /**
   * Ensure a split (center) results view exists and return it. Reuse existing when possible.
   */
  private async ensureSplitResultsView(): Promise<ResultsView> {
    // Reuse if alive
    if (this.splitLeaf && this.splitLeaf.view?.getViewType() === VIEW_TYPE_ANS_RESULTS) {
      const v = this.splitLeaf.view as unknown as ResultsView;
      // Reveal the leaf
      this.app.workspace.revealLeaf(this.splitLeaf);
      return v;
    }

    // Create new split from active leaf (center area). This splits to the right (vertical split).
    const leaf = this.app.workspace.getLeaf("split");
    await leaf.setViewState({ type: VIEW_TYPE_ANS_RESULTS, active: true });
    leaf.setPinned(true);
    this.splitLeaf = leaf;
    const view = leaf.view as unknown as ResultsView;
    return view;
  }

  /**
   * Ensure a popout window results view exists and return it. Reuse existing when possible.
   */
  private async ensureWindowResultsView(): Promise<ResultsView> {
    if (this.windowLeaf && this.windowLeaf.view?.getViewType() === VIEW_TYPE_ANS_RESULTS) {
      const v = this.windowLeaf.view as unknown as ResultsView;
      // Focus window if possible
      try {
        (v as any)?.win?.focus?.();
      } catch {}
      return v;
    }

    // Open a popout leaf (window)
    const pop = (this.app.workspace as any).openPopoutLeaf?.();
    if (!pop) {
      // Fallback: if popout not available, split instead
      console.warn("[ANS] Popout leaf not available; falling back to split.");
      return await this.ensureSplitResultsView();
    }
    const leaf: WorkspaceLeaf = pop;
    await leaf.setViewState({ type: VIEW_TYPE_ANS_RESULTS, active: true });
    try {
      leaf.setPinned(true);
    } catch {}
    this.windowLeaf = leaf;
    const view = leaf.view as unknown as ResultsView;
    return view;
  }

  async loadSettings() {
    const data = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS, data ?? {});
  }

  async saveSettings() {
    await this.saveData(this.settings);
  }
}
```

---

```resultsView.ts
// resultsView.ts
import { ItemView, WorkspaceLeaf } from "obsidian";
import type AdvancedNativeSearchPlugin from "./plugin";
import type { MatchLog } from "./search";
import { globToRegExp } from "./search";

export const VIEW_TYPE_ANS_RESULTS = "ans-results-view";

export class ResultsView extends ItemView {
  private plugin: AdvancedNativeSearchPlugin;
  private currentMode: "split" | "window" = "split";
  private caseSensitive = false;
  private results: MatchLog[] = [];
  private summary: { matchedFiles: number; totalLineHits: number; timeMs: number } | null = null;

  constructor(leaf: WorkspaceLeaf, plugin: AdvancedNativeSearchPlugin) {
    super(leaf);
    this.plugin = plugin;
  }

  getViewType(): string {
    return VIEW_TYPE_ANS_RESULTS;
  }

  getDisplayText(): string {
    return "ANS Results";
  }

  getIcon(): string {
    return "search";
  }

  async onOpen(): Promise<void> {
    this.render();
  }

  async onClose(): Promise<void> {
    // no-op
  }

  /**
   * Update results and re-render.
   */
  setData(
    results: MatchLog[],
    opts: {
      caseSensitive: boolean;
      displayMode: "split" | "window";
      summary: { matchedFiles: number; totalLineHits: number; timeMs: number } | null;
    }
  ) {
    this.results = results ?? [];
    this.caseSensitive = !!opts.caseSensitive;
    this.currentMode = opts.displayMode;
    this.summary = opts.summary ?? null;
    this.render();
  }

  private render() {
    const { contentEl } = this;
    contentEl.empty();

    // Root: make the view fill available space and allow the list to stretch.
    contentEl.style.display = "flex";
    contentEl.style.flexDirection = "column";
    contentEl.style.height = "100%";
    contentEl.style.minHeight = "0";

    // Header: Title + summary + toggles
    const header = contentEl.createDiv();
    header.style.display = "flex";
    header.style.alignItems = "center";
    header.style.justifyContent = "space-between";
    header.style.gap = "8px";
    header.style.marginBottom = "8px";

    const left = header.createDiv();
    const title = left.createEl("div", { text: "Search results" });
    title.addClass("setting-item-name");

    const sum = this.summary;
    const sub = left.createEl("div", {
      text:
        sum
          ? `Files: ${sum.matchedFiles}  •  Line hits: ${sum.totalLineHits}  •  ${sum.timeMs} ms`
          : `Results: ${this.results.length}`,
    });
    sub.style.color = "var(--text-muted)";
    sub.style.fontSize = "0.9em";

    const right = header.createDiv();
    right.style.display = "flex";
    right.style.alignItems = "center";
    right.style.gap = "6px";

    const splitBtn = right.createEl("button", { text: "Split" });
    const windowBtn = right.createEl("button", { text: "Window" });

    const applyToggleState = () => {
      splitBtn.disabled = this.currentMode === "split";
      windowBtn.disabled = this.currentMode === "window";
      splitBtn.style.opacity = splitBtn.disabled ? "0.6" : "1";
      windowBtn.style.opacity = windowBtn.disabled ? "0.6" : "1";
      splitBtn.title = "Show results in a split pane (center area).";
      windowBtn.title = "Show results in a popout window.";
    };
    applyToggleState();

    splitBtn.onclick = async () => {
      if (this.currentMode === "split") return;
      await this.plugin.requestSwitchDisplayMode("split");
    };
    windowBtn.onclick = async () => {
      if (this.currentMode === "window") return;
      await this.plugin.requestSwitchDisplayMode("window");
    };

    // Wrapper for the list area: occupy all remaining space.
    const listWrapper = contentEl.createDiv();
    listWrapper.style.flex = "1 1 auto";
    listWrapper.style.minHeight = "0";
    listWrapper.style.display = "flex";
    listWrapper.style.flexDirection = "column";

    // Results list: full height of remaining space; scroll when overflowing.
    const container = listWrapper.createDiv();
    container.style.display = "flex";
    container.style.flexDirection = "column";
    container.style.gap = "12px";
    container.style.flex = "1 1 auto";
    container.style.minHeight = "0";
    container.style.overflow = "auto";

    for (const r of this.results) {
      const group = container.createDiv();
      group.style.border = "1px solid var(--background-modifier-border)";
      group.style.borderRadius = "8px";
      group.style.padding = "8px";

      const header2 = group.createDiv();
      header2.style.display = "flex";
      header2.style.alignItems = "baseline";
      header2.style.justifyContent = "space-between";
      header2.style.gap = "8px";

      const left2 = header2.createDiv();
      const nameEl = left2.createEl("div", { text: r.name });
      nameEl.style.fontWeight = "600";
      const pathEl = left2.createEl("div", { text: r.path });
      pathEl.style.color = "var(--text-muted)";

      const right2 = header2.createDiv();
      right2.style.textAlign = "right";
      const hits = r.line?.hitCount ?? r.excerpts?.length ?? 0;
      right2.createEl("div", { text: `Hits: ${hits}` });
      right2.createEl("div", { text: `Size: ${r.stat.size}  •  mtime: ${new Date(r.stat.mtime).toLocaleString()}` });

      const list = group.createDiv();
      list.style.display = "flex";
      list.style.flexDirection = "column";
      list.style.gap = "8px";
      list.style.marginTop = "8px";

      for (const ex of r.excerpts ?? []) {
        const card = list.createDiv();
        card.style.border = "1px solid var(--background-modifier-border)";
        card.style.borderRadius = "6px";
        card.style.padding = "8px";
        card.style.cursor = "pointer";
        card.style.backgroundColor = "var(--background-secondary)";
        card.style.transition = "background-color 0.1s ease";
        card.onmouseenter = () => (card.style.backgroundColor = "var(--background-secondary-alt)");
        card.onmouseleave = () => (card.style.backgroundColor = "var(--background-secondary)");

        const meta = card.createDiv();
        meta.style.display = "flex";
        meta.style.alignItems = "center";
        meta.style.gap = "8px";
        meta.style.color = "var(--text-muted)";
        meta.style.fontSize = "0.9em";
        meta.createEl("span", { text: ex.line >= 0 ? `Line ${ex.line}` : "Synthetic" });
        meta.createEl("span", { text: `• ${ex.sources.join(", ")}` });

        const body = card.createDiv();
        body.style.marginTop = "6px";
        body.style.lineHeight = "1.5";
        body.style.wordBreak = "break-word";
        body.innerHTML = this.computeHighlightedHTML({ text: ex.text, sources: ex.sources }, r.matched, this.caseSensitive);

        card.onclick = async () => {
          await this.openFileAtLine(r.path, ex.line);
        };
      }
    }
  }

  private async openFileAtLine(path: string, line: number) {
    try {
      await this.app.workspace.openLinkText(path, "", false);
      const leaf: any = (this.app.workspace as any).getMostRecentLeaf?.() ?? null;
      const view: any = leaf?.view;
      const editor: any = view?.editor;

      if (editor && typeof line === "number" && line >= 0) {
        editor.setCursor({ line, ch: 0 });
        if (editor.scrollIntoView) {
          editor.scrollIntoView({ from: { line, ch: 0 }, to: { line, ch: 0 } }, true);
        } else if (view?.revealLine) {
          view.revealLine(line);
        }
      }
    } catch (e) {
      console.warn("[ANS] openFileAtLine failed:", e);
    }
  }

  /* =========================
     Highlight helpers (ported from modal UI)
     ========================= */

  private escapeHTML(s: string): string {
    return s.replace(/[&<>"']/g, (c) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }[c] as string));
  }

  private collectRangesPlain(text: string, term: string, caseSensitive: boolean, out: Array<[number, number]>) {
    if (!term) return;
    const t = caseSensitive ? term : term.toLowerCase();
    const hay = caseSensitive ? text : text.toLowerCase();
    let idx = 0;
    while (true) {
      const pos = hay.indexOf(t, idx);
      if (pos === -1) break;
      out.push([pos, pos + term.length]);
      idx = pos + Math.max(1, term.length);
    }
  }

  private collectRangesRegex(text: string, rx: RegExp, out: Array<[number, number]>) {
    const flags = rx.flags.includes("g") ? rx.flags : rx.flags + "g";
    const grx = new RegExp(rx.source, flags);
    for (const m of text.matchAll(grx)) {
      const start = m.index ?? 0;
      const end = start + (m[0]?.length ?? 0);
      if (end > start) out.push([start, end]);
    }
  }

  private collectRangesGlob(text: string, glob: string, caseSensitive: boolean, out: Array<[number, number]>) {
    const base = globToRegExp(glob, caseSensitive);
    const flags = base.flags.includes("g") ? base.flags : base.flags + "g";
    const grx = new RegExp(base.source, flags);
    for (const m of text.matchAll(grx)) {
      const start = m.index ?? 0;
      const end = start + (m[0]?.length ?? 0);
      if (end > start) out.push([start, end]);
    }
  }

  private mergeRanges(ranges: Array<[number, number]>): Array<[number, number]> {
    if (ranges.length === 0) return ranges;
    ranges.sort((a, b) => (a[0] - b[0]) || (a[1] - b[1]));
    const out: Array<[number, number]> = [];
    let [cs, ce] = ranges[0];
    for (let i = 1; i < ranges.length; i++) {
      const [s, e] = ranges[i];
      if (s <= ce) {
        ce = Math.max(ce, e);
      } else {
        out.push([cs, ce]);
        cs = s;
        ce = e;
      }
    }
    out.push([cs, ce]);
    return out;
  }

  private buildHighlightedHTML(
    text: string,
    opts: {
      lineTerms?: string[];
      contentPatterns?: string[];
      caseSensitive: boolean;
    }
  ): string {
    const ranges: Array<[number, number]> = [];

    // contentPatterns: regex literal, glob, or plain
    for (const pat of opts.contentPatterns ?? []) {
      const rx = this.tryParseExplicitRegex(pat);
      if (rx) {
        this.collectRangesRegex(text, rx, ranges);
      } else if (pat.includes("*") || pat.includes("?")) {
        this.collectRangesGlob(text, pat, opts.caseSensitive, ranges);
      } else {
        this.collectRangesPlain(text, pat, opts.caseSensitive, ranges);
      }
    }

    // lineTerms: plain substrings
    for (const term of opts.lineTerms ?? []) {
      this.collectRangesPlain(text, term, opts.caseSensitive, ranges);
    }

    const merged = this.mergeRanges(ranges);
    if (merged.length === 0) return this.escapeHTML(text);

    let html = "";
    let last = 0;
    for (const [s, e] of merged) {
      if (s > last) html += this.escapeHTML(text.slice(last, s));
      html += "<mark>" + this.escapeHTML(text.slice(s, e)) + "</mark>";
      last = e;
    }
    if (last < text.length) html += this.escapeHTML(text.slice(last));
    return html;
  }

  private tryParseExplicitRegex(pattern: string): RegExp | null {
    const m = pattern.match(/^\/(.+)\/([a-z]*)$/i);
    if (!m) return null;
    try {
      return new RegExp(m[1], m[2]);
    } catch {
      return null;
    }
  }

  private computeHighlightedHTML(
    excerpt: { text: string; sources: string[] },
    matched: MatchLog["matched"],
    caseSensitive: boolean
  ): string {
    const contentSources = excerpt.sources.filter((s) => s.startsWith("content:"));
    const contentPatterns = contentSources.map((s) => s.slice("content:".length)).filter(Boolean);
    const lineTerms = matched?.lineTerms ?? [];
    return this.buildHighlightedHTML(excerpt.text, {
      lineTerms,
      contentPatterns,
      caseSensitive,
    });
  }
}
```

---

```search.ts
// search.ts
import { App, TFile, prepareFuzzySearch, prepareSimpleSearch } from "obsidian";

/**
 * Search mode for the Global Query.
 */
export type SearchMode = "fuzzy" | "simple" | "regex";

/**
 * Sort options.
 */
export type SortMode = "mtime-desc" | "mtime-asc" | "path-asc";

/**
 * Target fields for the Global Query.
 * By default all are true (search across the entire vault).
 */
export interface GlobalQueryTargets {
  body: boolean;
  name: boolean;
  path: boolean;
  frontmatter: boolean; // both key name and values
  tags: boolean;
  headings: boolean;
}

/**
 * User-selectable search options.
 * Note:
 * - mode affects only the Global Query.
 * - caseSensitive affects only filter evaluations (file/path/tag/content/line/headings/property).
 */
export interface SearchOptions {
  mode: SearchMode;
  caseSensitive: boolean;
  sort: SortMode;
  limit?: number | null;
  globalQueryTargets: GlobalQueryTargets;
}

/**
 * Parsed query (filters are all AND-combined).
 */
export interface ParsedQuery {
  // Global query (free-form across selected vault fields; prepare*Search/regex applied to strings)
  globalQuery: string;

  // Dedicated operators (AND-combined)
  filePatterns: string[];     // file:
  pathPatterns: string[];     // path:
  tagFilters: string[];       // tag: (may include leading #)
  contentPatterns: string[];  // content:
  linePatterns: string[];     // line: (same line must contain ALL terms; implemented via a single lookahead regex)
  headingPatterns: string[];  // headings: (was section:)
  // Frontmatter / properties
  propertyFilters: Array<{ name: string; value: string | RegExp | null }>;
}

/**
 * Excerpt info for hit lines.
 */
export interface Excerpt {
  line: number;       // 0-based (use -1 for synthetic lines)
  text: string;       // formatted line text or synthetic description
  sources: string[];  // reasons, e.g., "line", "content:<pattern>", "globalQuery:<mode>", etc.
}

/**
 * Filter-wise hit stats (for accepted files).
 */
export interface FilterHitStats {
  file?: number;
  path?: number;
  tag?: number;
  property?: number;
  headings?: number;
  content?: number;
  line?: number;
  globalQuery?: number;
  // breakdown per Global Query target
  globalQueryBreakdown?: {
    body?: number;
    name?: number;
    path?: number;
    frontmatter?: number;
    tags?: number;
    headings?: number;
  };
}

/**
 * Result entry for logging.
 */
export interface MatchLog {
  path: string;
  name: string;
  stat: { mtime: number; size: number };
  matched: {
    file?: string[];
    path?: string[];
    tags?: string[];
    properties?: Array<{ name: string; value: string | RegExp | null }>;
    globalQuery?: boolean;
    contentPatterns?: string[];
    headingPatterns?: string[];
    lineTerms?: string[];
  };
  // line hit detail
  line: {
    patternLiteral: string | null;
    hitCount: number;
    hitLineIndices: number[];
  } | null;
  // prepare*Search result for body (if any)
  searchResult?: any;
  // regex mode: total match count across targets (approx)
  regexMatchCount?: number;
  // excerpts (max N lines)
  excerpts?: Excerpt[];
  // filter-wise hits
  filterHits?: FilterHitStats;
}

/**
 * Utility: parse explicit regex literal /pattern/flags into RegExp.
 */
export function tryParseExplicitRegex(pattern: string): RegExp | null {
  const m = pattern.match(/^\/(.+)\/([a-z]*)$/i);
  if (!m) return null;
  try {
    return new RegExp(m[1], m[2]);
  } catch {
    return null;
  }
}

/**
 * Utility: convert glob (* ?) to RegExp.
 */
export function globToRegExp(glob: string, caseSensitive: boolean): RegExp {
  const esc = (s: string) => s.replace(/[.+^${}()|[\]\\]/g, "\\$&");
  let pattern = "";
  for (const ch of glob) {
    if (ch === "*") pattern += ".*";
    else if (ch === "?") pattern += ".";
    else pattern += esc(ch);
  }
  const flags = caseSensitive ? "" : "i";
  return new RegExp(pattern, flags);
}

/**
 * Utility: substring includes with case sensitivity.
 */
function includesWithCase(haystack: string, needle: string, caseSensitive: boolean): boolean {
  if (!caseSensitive) {
    return haystack.toLowerCase().includes(needle.toLowerCase());
  }
  return haystack.includes(needle);
}

/**
 * Match a value against a pattern:
 * - explicit /regex/ -> RegExp
 * - includes * or ? -> glob
 * - otherwise -> substring match
 */
function matchPattern(v: string, pat: string, caseSensitive: boolean): boolean {
  const rx = tryParseExplicitRegex(pat);
  if (rx) return rx.test(v);

  if (pat.includes("*") || pat.includes("?")) {
    const grx = globToRegExp(pat, caseSensitive);
    return grx.test(v);
  }

  return includesWithCase(v, pat, caseSensitive);
}

/**
 * Collect tags for a file (# stripped, unique).
 * - cache.tags (in-body tags)
 * - frontmatter.tags (string | string[])
 */
function getTagsForFile(app: App, file: TFile): Set<string> {
  const set = new Set<string>();
  const cache = app.metadataCache.getFileCache(file);

  // in-body tags
  const tags = cache?.tags;
  if (Array.isArray(tags)) {
    for (const t of tags) {
      if (!t?.tag) continue;
      const raw = String(t.tag);
      const cleaned = raw.startsWith("#") ? raw.slice(1) : raw;
      if (cleaned) set.add(cleaned);
    }
  }

  // frontmatter tags
  const fm = cache?.frontmatter;
  const fmTags = fm?.tags;
  const push = (x: unknown) => {
    const s = String(x ?? "").trim();
    if (!s) return;
    const cleaned = s.startsWith("#") ? s.slice(1) : s;
    if (cleaned) set.add(cleaned);
  };
  if (Array.isArray(fmTags)) {
    for (const v of fmTags) push(v);
  } else if (typeof fmTags === "string") {
    // allow comma/space separated
    for (const v of fmTags.split(/[,\s]+/)) push(v);
  }

  return set;
}

/**
 * Frontmatter property match.
 */
function matchProperty(cache: any, name: string, value: string | RegExp | null, caseSensitive: boolean): boolean {
  const fm = cache?.frontmatter;
  if (!fm) return false;

  const v = fm[name];
  if (typeof v === "undefined") return false;

  if (value === null) {
    // existence check only
    return true;
  }

  // value match
  if (value instanceof RegExp) {
    return value.test(String(v));
  }

  // array or scalar (array is ANY match)
  if (Array.isArray(v)) {
    return v.some((item) => {
      const s = String(item ?? "");
      return caseSensitive ? s === value : s.toLowerCase() === value.toLowerCase();
    });
  } else {
    const s = String(v ?? "");
    return caseSensitive ? s === value : s.toLowerCase() === value.toLowerCase();
  }
}

/**
 * Heading match (from cache.headings).
 */
function matchHeading(app: App, file: TFile, pattern: string, caseSensitive: boolean): boolean {
  const cache = app.metadataCache.getFileCache(file);
  const headings = cache?.headings;
  if (!Array.isArray(headings) || headings.length === 0) return false;

  const rx = tryParseExplicitRegex(pattern);
  for (const h of headings) {
    const text: string = h.heading ?? "";
    if (!text) continue;
    if (rx) {
      if (rx.test(text)) return true;
    } else {
      if (matchPattern(text, pattern, caseSensitive)) return true;
    }
  }
  return false;
}

/**
 * Count matches for line: AND regex across lines.
 */
function countLineMatches_AND(
  text: string,
  andPatternLiteral: string | null,
  caseSensitive: boolean
): {
  hasAnyHit: boolean;
  hitCount: number;
  hitLineIndices: number[];
} {
  if (!andPatternLiteral) {
    return { hasAnyHit: true, hitCount: 0, hitLineIndices: [] };
  }
  const lines = text.split(/\r?\n/);
  const rx =
    tryParseExplicitRegex(andPatternLiteral) ??
    new RegExp(andPatternLiteral, caseSensitive ? "" : "i");

  const hitSet = new Set<number>();
  for (let i = 0; i < lines.length; i++) {
    if (rx.test(lines[i])) {
      hitSet.add(i);
    }
  }
  const indices = Array.from(hitSet.values()).sort((a, b) => a - b);
  return {
    hasAnyHit: indices.length > 0,
    hitCount: indices.length,
    hitLineIndices: indices,
  };
}

/**
 * content: pattern match in text.
 */
function contentContains(text: string, pattern: string, caseSensitive: boolean): boolean {
  const rx = tryParseExplicitRegex(pattern);
  if (rx) return rx.test(text);
  return matchPattern(text, pattern, caseSensitive);
}

/**
 * Format a line for logging.
 */
function formatLineForLog(s: string, maxLen = 240): string {
  const cleaned = s.replace(/\t/g, "  ").replace(/\r/g, "").replace(/\u0000/g, "");
  if (cleaned.length <= maxLen) return cleaned;
  return cleaned.slice(0, maxLen - 1) + "…";
}

/**
 * Extract hit lines:
 * - line: apply single AND regex per line.
 * - content: apply each pattern per line.
 * - Global Query (body only here): simple/fuzzy via searchFn per line, regex via regexForGlobalQuery per line.
 *
 * Note: non-body Global Query excerpts (name/path/frontmatter/tags/headings) are generated separately and merged.
 */
function extractHitLines(
  text: string,
  parsed: ParsedQuery,
  options: SearchOptions,
  searchFn: ((text: string) => any) | null,
  regexForGlobalQuery: RegExp | null,
  perFileLimit = 10
): Excerpt[] {
  const { caseSensitive, mode } = options;
  const lines = text.split(/\r?\n/);

  // line index -> reasons(Set)
  const reasons = new Map<number, Set<string>>();

  const addReason = (idx: number, r: string) => {
    if (idx < 0 || idx >= lines.length) return;
    if (!reasons.has(idx)) reasons.set(idx, new Set<string>());
    reasons.get(idx)!.add(r);
  };

  // line: AND
  if (parsed.linePatterns.length > 0) {
    const literal = parsed.linePatterns[0];
    const rx = tryParseExplicitRegex(literal) ?? new RegExp(literal, caseSensitive ? "" : "i");
    for (let i = 0; i < lines.length; i++) {
      if (rx.test(lines[i])) addReason(i, "line");
    }
  }

  // content: AND for file acceptance, but excerpts list OR hits per pattern
  if (parsed.contentPatterns.length > 0) {
    for (const pat of parsed.contentPatterns) {
      for (let i = 0; i < lines.length; i++) {
        if (contentContains(lines[i], pat, caseSensitive)) addReason(i, `content:${pat}`);
      }
    }
  }

  // Global Query on body (simple/fuzzy/regex)
  if (parsed.globalQuery && options.globalQueryTargets.body) {
    if ((mode === "simple" || mode === "fuzzy") && searchFn) {
      for (let i = 0; i < lines.length; i++) {
        if (searchFn(lines[i])) addReason(i, `globalQuery:${mode}`);
      }
    } else if (mode === "regex" && regexForGlobalQuery) {
      // Use non-global regex for per-line test to avoid lastIndex issues.
      for (let i = 0; i < lines.length; i++) {
        if (regexForGlobalQuery.test(lines[i])) addReason(i, "globalQuery:regex");
      }
    }
  }

  const all = Array.from(reasons.entries())
    .sort((a, b) => a[0] - b[0])
    .map<Excerpt>(([idx, set]) => ({
      line: idx,
      text: formatLineForLog(lines[idx]),
      sources: Array.from(set.values()),
    }));

  return all.slice(0, perFileLimit);
}

/**
 * Convert offset to line index (0-based).
 */
function offsetToLine(text: string, offset: number): number {
  if (offset <= 0) return 0;
  let line = 0;
  const len = Math.min(offset, text.length);
  for (let i = 0; i < len; i++) {
    if (text.charCodeAt(i) === 10 /* \n */) line++;
  }
  return line;
}

/**
 * Build heading excerpts:
 * - use position.start.line or fallback from position.start.offset.
 * - sources use "headings:<pattern>".
 */
function buildHeadingExcerpts(
  app: App,
  file: TFile,
  text: string,
  patterns: string[],
  caseSensitive: boolean
): Excerpt[] {
  if (!patterns || patterns.length === 0) return [];
  const cache = app.metadataCache.getFileCache(file);

  const headings = (cache?.headings ?? []) as any[];
  if (headings.length === 0) return [];

  const lines = text.split(/\r?\n/);
  const lineToSources = new Map<number, Set<string>>();

  for (const h of headings) {
    const headingText: string = String(h?.heading ?? "");
    if (!headingText) continue;

    for (const pat of patterns) {
      const rx = tryParseExplicitRegex(pat);
      const ok = rx ? rx.test(headingText) : matchPattern(headingText, pat, caseSensitive);
      if (!ok) continue;

      let lineIdx: number | undefined = h?.position?.start?.line;
      if (typeof lineIdx !== "number") {
        const off = h?.position?.start?.offset;
        if (typeof off === "number") {
          lineIdx = offsetToLine(text, off);
        }
      }
      if (typeof lineIdx !== "number") continue;

      if (!lineToSources.has(lineIdx)) lineToSources.set(lineIdx, new Set<string>());
      lineToSources.get(lineIdx)!.add(`headings:${pat}`);
    }
  }

  const excerpts: Excerpt[] = Array.from(lineToSources.entries())
    .sort((a, b) => a[0] - b[0])
    .map<Excerpt>(([idx, srcs]) => ({
      line: idx,
      text: lines[idx] ?? "",
      sources: Array.from(srcs.values()),
    }));

  return excerpts;
}

/**
 * Merge excerpts by line index, union sources. Apply perFileLimit.
 */
function mergeExcerpts(base: Excerpt[] | undefined, add: Excerpt[], perFileLimit = 10): Excerpt[] {
  const map = new Map<number, { text: string; sources: Set<string> }>();

  const push = (arr?: Excerpt[]) => {
    if (!arr) return;
    for (const ex of arr) {
      const cur = map.get(ex.line);
      if (cur) {
        if (!cur.text && ex.text) cur.text = ex.text;
        for (const s of ex.sources) cur.sources.add(s);
      } else {
        map.set(ex.line, { text: ex.text, sources: new Set(ex.sources) });
      }
    }
  };

  push(base);
  push(add);

  return Array.from(map.entries())
    .sort((a, b) => a[0] - b[0])
    .map<Excerpt>(([line, v]) => ({
      line,
      text: v.text,
      sources: Array.from(v.sources.values()),
    }))
    .slice(0, perFileLimit);
}

/**
 * Ensure a RegExp has global flag.
 */
function ensureGlobalRegex(rx: RegExp): RegExp {
  const flags = rx.flags.includes("g") ? rx.flags : rx.flags + "g";
  return new RegExp(rx.source, flags);
}

/**
 * Count regex matches using matchAll on a globalized regex.
 */
function countRegexMatches(text: string, rx: RegExp): number {
  const grx = ensureGlobalRegex(rx);
  let count = 0;
  for (const _ of text.matchAll(grx)) count++;
  return count;
}

/**
 * Test a single string against the Global Query.
 * Returns hit boolean and count (1 for simple/fuzzy; match count for regex).
 * Regex count uses globalized regex + matchAll for accuracy.
 */
function testGlobalString(
  s: string,
  searchFn: ((text: string) => any) | null,
  regex: RegExp | null,
  mode: SearchMode
): { hit: boolean; count: number } {
  if (!s) return { hit: false, count: 0 };
  if (mode === "regex" && regex) {
    const count = countRegexMatches(s, regex);
    return { hit: count > 0, count };
  } else if ((mode === "simple" || mode === "fuzzy") && searchFn) {
    const r = !!searchFn(s);
    return { hit: r, count: r ? 1 : 0 };
  }
  return { hit: false, count: 0 };
}

/**
 * Build synthetic excerpts for non-body Global Query targets.
 * Adds descriptive lines for name/path/frontmatter/tags/headings hits.
 */
function buildGlobalSyntheticExcerpts(
  text: string,
  name: string,
  path: string,
  cache: any,
  targets: GlobalQueryTargets,
  searchFn: ((text: string) => any) | null,
  regex: RegExp | null,
  mode: SearchMode
): Excerpt[] {
  const ex: Excerpt[] = [];
  const lines = text.split(/\r?\n/);

  const pushSynthetic = (label: string, value: string) => {
    ex.push({
      line: -1,
      text: `[${label}] ${value}`,
      sources: [`globalQuery:${mode}:${label.toLowerCase()}`],
    });
  };

  // name
  if (targets.name) {
    const { hit } = testGlobalString(name, searchFn, regex, mode);
    if (hit) pushSynthetic("name", name);
  }

  // path
  if (targets.path) {
    const { hit } = testGlobalString(path, searchFn, regex, mode);
    if (hit) pushSynthetic("path", path);
  }

  // frontmatter
  if (targets.frontmatter) {
    const fm = cache?.frontmatter;
    if (fm && typeof fm === "object") {
      for (const key of Object.keys(fm)) {
        const keyRes = testGlobalString(key, searchFn, regex, mode);
        if (keyRes.hit) pushSynthetic("frontmatter-key", key);

        const val = fm[key];
        const values: string[] = Array.isArray(val)
          ? val.map((x: any) => String(x ?? ""))
          : [String(val ?? "")];

        for (const v of values) {
          const res = testGlobalString(v, searchFn, regex, mode);
          if (res.hit) pushSynthetic("frontmatter", `${key}: ${v}`);
        }
      }
    }
  }

  // tags
  if (targets.tags) {
    const set = new Set<string>();
    // in-body tags
    const tags = cache?.tags;
    if (Array.isArray(tags)) {
      for (const t of tags) {
        if (!t?.tag) continue;
        const raw = String(t.tag);
        const cleaned = raw.startsWith("#") ? raw.slice(1) : raw;
        if (cleaned) set.add(cleaned);
      }
    }
    // frontmatter tags
    const fm = cache?.frontmatter;
    const fmTags = fm?.tags;
    const pushTagVal = (x: unknown) => {
      const s = String(x ?? "").trim();
      if (!s) return;
      const cleaned = s.startsWith("#") ? s.slice(1) : s;
      if (cleaned) set.add(cleaned);
    };
    if (Array.isArray(fmTags)) {
      for (const v of fmTags) pushTagVal(v);
    } else if (typeof fmTags === "string") {
      for (const v of fmTags.split(/[,\s]+/)) pushTagVal(v);
    }

    for (const tg of set) {
      const res = testGlobalString(tg, searchFn, regex, mode);
      if (res.hit) pushSynthetic("tag", tg);
    }
  }

  // headings (use heading text and line excerpt if available)
  if (targets.headings) {
    const headings = (cache?.headings ?? []) as any[];
    for (const h of headings) {
      const headingText: string = String(h?.heading ?? "");
      if (!headingText) continue;
      const res = testGlobalString(headingText, searchFn, regex, mode);
      if (res.hit) {
        let lineIdx: number | undefined = h?.position?.start?.line;
        if (typeof lineIdx !== "number") {
          const off = h?.position?.start?.offset;
          if (typeof off === "number") {
            lineIdx = offsetToLine(text, off);
          }
        }
        const excerptText =
          typeof lineIdx === "number" ? (lines[lineIdx] ?? headingText) : headingText;
        ex.push({
          line: typeof lineIdx === "number" ? lineIdx : -1,
          text: `[headings] ${excerptText}`,
          sources: [`globalQuery:${mode}:headings`],
        });
      }
    }
  }

  return ex;
}

/**
 * Build a single AND lookahead regex literal for line: terms.
 * Example: ["tool","har"] -> '/^(?=.*tool)(?=.*har).*$/i'
 */
export function buildLineRegexLiteral_AND(terms: string[], caseSensitive: boolean): string {
  const escapeRegex = (s: string) => s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  const core = terms.map((t) => `(?=.*${escapeRegex(t)})`).join("") + ".*";
  const flags = caseSensitive ? "" : "i";
  return `/^${core}$/` + (flags ? flags : "");
}

/**
 * Execute search across the vault. Returns matches and summary stats.
 * UI表示やNoticeは含めません（plugin.ts側で実行）。
 */
export async function runSearch(
  app: App,
  parsed: ParsedQuery,
  options: SearchOptions,
  uiState: { lineTerms: string[] }
): Promise<{
  matches: MatchLog[];
  summary: { matchedFiles: number; totalLineHits: number; timeMs: number };
}> {
  const t0 = performance.now();
  const files = app.vault.getMarkdownFiles();

  if (!files.length) {
    return { matches: [], summary: { matchedFiles: 0, totalLineHits: 0, timeMs: 0 } };
  }

  const { mode, caseSensitive, sort, limit, globalQueryTargets } = options;

  // prepare*Search for Global Query (returns truthy for matching strings)
  let searchFn: ((text: string) => any) | null = null;
  if (parsed.globalQuery) {
    if (mode === "simple") {
      searchFn = prepareSimpleSearch(parsed.globalQuery);
    } else if (mode === "fuzzy") {
      searchFn = prepareFuzzySearch(parsed.globalQuery);
    } else {
      searchFn = null; // regex handled separately
    }
  }

  // regex for Global Query:
  // - regexForGlobalQuerySearch: used for per-line/boolean tests (non-global to avoid lastIndex issues).
  let regexForGlobalQuerySearch: RegExp | null = null;

  if (mode === "regex" && parsed.globalQuery) {
    const explicit = tryParseExplicitRegex(parsed.globalQuery);
    if (explicit) {
      regexForGlobalQuerySearch = new RegExp(explicit.source, explicit.flags.replace(/g/g, ""));
    } else {
      regexForGlobalQuerySearch = new RegExp(parsed.globalQuery, "i");
    }
  }

  // Pre-sort files by selected criterion for top-N retrieval with early break.
  const sortedFiles = [...files];
  if (sort === "mtime-desc") {
    sortedFiles.sort((a, b) => b.stat.mtime - a.stat.mtime);
  } else if (sort === "mtime-asc") {
    sortedFiles.sort((a, b) => a.stat.mtime - b.stat.mtime);
  } else if (sort === "path-asc") {
    sortedFiles.sort((a, b) => a.path.localeCompare(b.path));
  }

  const matches: MatchLog[] = [];
  let totalLineHits = 0;
  let matchedFiles = 0;
  const maxResults = typeof limit === "number" && limit > 0 ? limit : Infinity;

  for (const file of sortedFiles) {
    const cache = app.metadataCache.getFileCache(file);
    const path = file.path;
    const name = file.name;

    // file: (AND)
    if (parsed.filePatterns.length > 0) {
      const ok = parsed.filePatterns.every((pat) => matchPattern(name, pat, caseSensitive));
      if (!ok) continue;
    }
    // path: (AND)
    if (parsed.pathPatterns.length > 0) {
      const ok = parsed.pathPatterns.every((pat) => matchPattern(path, pat, caseSensitive));
      if (!ok) continue;
    }
    // tag: (AND)
    if (parsed.tagFilters.length > 0) {
      const tags = getTagsForFile(app, file);
      const ok = parsed.tagFilters.every((tg) => {
        const rx = tryParseExplicitRegex(tg);
        if (rx) {
          for (const t of tags) if (rx.test(t)) return true;
          return false;
        }
        return tags.has(tg);
      });
      if (!ok) continue;
    }
    // property: (AND)
    if (parsed.propertyFilters.length > 0) {
      const ok = parsed.propertyFilters.every((pf) =>
        matchProperty(cache, pf.name, pf.value, caseSensitive)
      );
      if (!ok) continue;
    }
    // headings: (AND)
    if (parsed.headingPatterns.length > 0) {
      const ok = parsed.headingPatterns.every((pat) =>
        matchHeading(app, file, pat, caseSensitive)
      );
      if (!ok) continue;
    }

    // read body for content/line/Global Query body/headings excerpts
    const text = await app.vault.cachedRead(file);

    // content: (AND)
    if (parsed.contentPatterns.length > 0) {
      const ok = parsed.contentPatterns.every((pat) => contentContains(text, pat, caseSensitive));
      if (!ok) continue;
    }

    // line: (AND on same line)
    let lineDetail: MatchLog["line"] = null;
    if (parsed.linePatterns.length > 0) {
      const { hasAnyHit, hitCount, hitLineIndices } = countLineMatches_AND(
        text,
        parsed.linePatterns[0] ?? null,
        caseSensitive
      );
      if (!hasAnyHit) continue;
      totalLineHits += hitCount;
      lineDetail = {
        patternLiteral: parsed.linePatterns[0],
        hitCount,
        hitLineIndices,
      };
    }

    // Global Query (OR across selected targets) — at least one target must hit
    let gqHit = !parsed.globalQuery; // if not specified, treat as pass-through
    const gqBreakdown: FilterHitStats["globalQueryBreakdown"] = {};
    let regexMatchTotal = 0;

    // body (collect line hits count for breakdown)
    const lines = text.split(/\r?\n/);
    let searchResultBody: any = null;
    if (parsed.globalQuery && globalQueryTargets.body) {
      if ((mode === "simple" || mode === "fuzzy") && searchFn) {
        searchResultBody = searchFn(text);
        if (searchResultBody) {
          gqHit = true;
          let c = 0;
          for (const ln of lines) {
            if (searchFn(ln)) c++;
          }
          gqBreakdown.body = c;
        }
      } else if (mode === "regex" && regexForGlobalQuerySearch) {
        const cnt = countRegexMatches(text, regexForGlobalQuerySearch);
        if (cnt > 0) {
          gqHit = true;
          gqBreakdown.body = cnt;
          regexMatchTotal += cnt;
        }
      }
    }

    // name
    if (parsed.globalQuery && globalQueryTargets.name) {
      const { hit, count } = testGlobalString(name, searchFn, regexForGlobalQuerySearch, mode);
      if (hit) {
        gqHit = true;
        gqBreakdown.name = (gqBreakdown.name ?? 0) + count;
        if (mode === "regex") regexMatchTotal += count;
      }
    }

    // path
    if (parsed.globalQuery && globalQueryTargets.path) {
      const { hit, count } = testGlobalString(path, searchFn, regexForGlobalQuerySearch, mode);
      if (hit) {
        gqHit = true;
        gqBreakdown.path = (gqBreakdown.path ?? 0) + count;
        if (mode === "regex") regexMatchTotal += count;
      }
    }

    // frontmatter (keys and values)
    if (parsed.globalQuery && globalQueryTargets.frontmatter) {
      const fm = cache?.frontmatter;
      if (fm && typeof fm === "object") {
        let localCount = 0;
        for (const key of Object.keys(fm)) {
          const keyRes = testGlobalString(key, searchFn, regexForGlobalQuerySearch, mode);
          if (keyRes.hit) localCount += keyRes.count;

          const val = fm[key];
          const values: string[] = Array.isArray(val)
            ? val.map((x: any) => String(x ?? ""))
            : [String(val ?? "")];

          for (const v of values) {
            const res = testGlobalString(v, searchFn, regexForGlobalQuerySearch, mode);
            if (res.hit) localCount += res.count;
          }
        }
        if (localCount > 0) {
          gqHit = true;
          gqBreakdown.frontmatter = (gqBreakdown.frontmatter ?? 0) + localCount;
          if (mode === "regex") regexMatchTotal += localCount;
        }
      }
    }

    // tags
    if (parsed.globalQuery && globalQueryTargets.tags) {
      const set = getTagsForFile(app, file);
      let localCount = 0;
      for (const tg of set) {
        const res = testGlobalString(tg, searchFn, regexForGlobalQuerySearch, mode);
        if (res.hit) localCount += res.count;
      }
      if (localCount > 0) {
        gqHit = true;
        gqBreakdown.tags = (gqBreakdown.tags ?? 0) + localCount;
        if (mode === "regex") regexMatchTotal += localCount;
      }
    }

    // headings (use heading text; excerpts merged separately)
    if (parsed.globalQuery && globalQueryTargets.headings) {
      const headings = (cache?.headings ?? []) as any[];
      let localCount = 0;
      for (const h of headings) {
        const headingText: string = String(h?.heading ?? "");
        if (!headingText) continue;
        const res = testGlobalString(headingText, searchFn, regexForGlobalQuerySearch, mode);
        if (res.hit) localCount += res.count;
      }
      if (localCount > 0) {
        gqHit = true;
        gqBreakdown.headings = (gqBreakdown.headings ?? 0) + localCount;
        if (mode === "regex") regexMatchTotal += localCount;
      }
    }

    if (!gqHit) continue; // Global Query specified but no target hit

    // Accepted file
    matchedFiles += 1;

    // excerpts: base (line/content/global body), add heading filter excerpts, add synthetic global-target excerpts
    const baseExcerpts = extractHitLines(
      text,
      parsed,
      options,
      searchFn,
      regexForGlobalQuerySearch,
      10
    );

    const headingFilterExcerpts = buildHeadingExcerpts(
      app,
      file,
      text,
      parsed.headingPatterns,
      caseSensitive
    );

    const globalSyntheticExcerpts = buildGlobalSyntheticExcerpts(
      text,
      name,
      path,
      cache,
      globalQueryTargets,
      searchFn,
      regexForGlobalQuerySearch,
      mode
    );

    const mergedExcerpts1 = mergeExcerpts(baseExcerpts, headingFilterExcerpts, 10);
    const mergedExcerpts = mergeExcerpts(mergedExcerpts1, globalSyntheticExcerpts, 10);

    // filter-wise hit stats
    const filterHits: FilterHitStats = {};

    if (parsed.filePatterns.length > 0) {
      filterHits.file = parsed.filePatterns.reduce(
        (acc, pat) => acc + (matchPattern(name, pat, caseSensitive) ? 1 : 0),
        0
      );
    }
    if (parsed.pathPatterns.length > 0) {
      filterHits.path = parsed.pathPatterns.reduce(
        (acc, pat) => acc + (matchPattern(path, pat, caseSensitive) ? 1 : 0),
        0
      );
    }
    if (parsed.tagFilters.length > 0) {
      const tagSet = getTagsForFile(app, file);
      filterHits.tag = parsed.tagFilters.reduce((acc, tg) => {
        const rx = tryParseExplicitRegex(tg);
        if (rx) {
          for (const t of tagSet) if (rx.test(t)) return acc + 1;
          return acc;
        } else {
          return acc + (tagSet.has(tg) ? 1 : 0);
        }
      }, 0);
    }
    if (parsed.propertyFilters.length > 0) {
      filterHits.property = parsed.propertyFilters.reduce(
        (acc, pf) => acc + (matchProperty(cache, pf.name, pf.value, caseSensitive) ? 1 : 0),
        0
      );
    }
    if (parsed.headingPatterns.length > 0) {
      filterHits.headings = parsed.headingPatterns.reduce(
        (acc, pat) => acc + (matchHeading(app, file, pat, caseSensitive) ? 1 : 0),
        0
      );
    }
    if (parsed.contentPatterns.length > 0) {
      filterHits.content = parsed.contentPatterns.reduce(
        (acc, pat) => acc + (contentContains(text, pat, caseSensitive) ? 1 : 0),
        0
      );
    }
    if (parsed.linePatterns.length > 0) {
      filterHits.line = lineDetail?.hitCount ?? 0;
    }

    // Global Query breakdown and total
    if (parsed.globalQuery) {
      filterHits.globalQueryBreakdown = {
        body: gqBreakdown.body ?? 0,
        name: gqBreakdown.name ?? 0,
        path: gqBreakdown.path ?? 0,
        frontmatter: gqBreakdown.frontmatter ?? 0,
        tags: gqBreakdown.tags ?? 0,
        headings: gqBreakdown.headings ?? 0,
      };
      filterHits.globalQuery = Object.values(filterHits.globalQueryBreakdown).reduce((a, b) => a + (b ?? 0), 0);
    }

    const logEntry: MatchLog = {
      path,
      name,
      stat: { mtime: file.stat.mtime, size: file.stat.size },
      matched: {
        file: parsed.filePatterns.length ? [...parsed.filePatterns] : undefined,
        path: parsed.pathPatterns.length ? [...parsed.pathPatterns] : undefined,
        tags: parsed.tagFilters.length ? [...parsed.tagFilters] : undefined,
        properties: parsed.propertyFilters.length ? [...parsed.propertyFilters] : undefined,
        globalQuery: !!parsed.globalQuery,
        contentPatterns: parsed.contentPatterns.length ? [...parsed.contentPatterns] : undefined,
        headingPatterns: parsed.headingPatterns.length ? [...parsed.headingPatterns] : undefined,
        lineTerms: uiState.lineTerms.length ? [...uiState.lineTerms] : undefined,
      },
      line: lineDetail,
      searchResult: (mode === "simple" || mode === "fuzzy") && parsed.globalQuery && globalQueryTargets.body && searchFn ? searchFn(text) : undefined,
      regexMatchCount: (mode === "regex" && parsed.globalQuery) ? regexMatchTotal : undefined,
      excerpts: mergedExcerpts,
      filterHits,
    };

    matches.push(logEntry);
    if (matches.length >= maxResults) break;
  }

  const t1 = performance.now();

  return {
    matches,
    summary: {
      matchedFiles,
      totalLineHits,
      timeMs: Math.round(t1 - t0),
    },
  };
}
```

---

```ui.ts
// ui.ts
import { App, Modal, Notice } from "obsidian";
import {
  ParsedQuery,
  SearchOptions,
  SearchMode,
  SortMode,
  tryParseExplicitRegex,
  buildLineRegexLiteral_AND,
} from "./search";

/**
 * Tokenizer: keep phrases in double quotes, strip quotes.
 * Example: hello "quick brown" tag:#x -> ["hello", "quick brown", "tag:#x"]
 */
function tokenizeWithQuotes(input: string): string[] {
  const tokens: string[] = [];
  let i = 0;
  const n = input.length;
  while (i < n) {
    while (i < n && /\s/.test(input[i])) i++;
    if (i >= n) break;

    if (input[i] === '"') {
      i++;
      let buf = "";
      while (i < n && input[i] !== '"') {
        buf += input[i++];
      }
      if (i < n && input[i] === '"') i++;
      if (buf.length) tokens.push(buf);
    } else {
      let buf = "";
      while (i < n && !/\s/.test(input[i])) {
        buf += input[i++];
      }
      if (buf.length) tokens.push(buf);
    }
  }
  return tokens;
}

/* =========================
   Query Prompt Modal (Filter Builder)
   ========================= */

export class QueryPromptModal extends Modal {
  private onSubmit: (parsed: ParsedQuery, options: SearchOptions, uiState: { lineTerms: string[] }) => void;

  // internal state (all AND)
  private filePatterns: string[] = [];
  private pathPatterns: string[] = [];
  private tagFilters: string[] = [];
  private contentPatterns: string[] = [];
  private lineTerms: string[] = [];
  private headingPatterns: string[] = [];
  private propertyFilters: Array<{ name: string; value: string | RegExp | null }> = [];

  // Global Query input (prepare*Search / regex)
  private globalQueryInputEl!: HTMLInputElement;

  // options
  private modeSelect!: HTMLSelectElement;      // affects Global Query only
  private csCheckbox!: HTMLInputElement;       // affects filters only
  private sortSelect!: HTMLSelectElement;
  private limitInput!: HTMLInputElement;

  // Global Query targets
  private gqTargetCheckboxes: {
    body: HTMLInputElement;
    name: HTMLInputElement;
    path: HTMLInputElement;
    frontmatter: HTMLInputElement;
    tags: HTMLInputElement;
    headings: HTMLInputElement;
  } | null = null;

  constructor(app: App, onSubmit: (parsed: ParsedQuery, options: SearchOptions, uiState: { lineTerms: string[] }) => void) {
    super(app);
    this.onSubmit = onSubmit;
  }

  onOpen() {
    const { contentEl } = this;
    contentEl.empty();

    contentEl.createEl("h3", { text: "Advanced Native-like Search (Filter Builder)" });

    const info = contentEl.createEl("div");
    info.addClass("setting-item-description");
    info.setText("Enter text for each option and click '+' to add filters. Added filters are AND-combined.");

    // Global Query section (mode applies here)
    this.makeGlobalQuerySection(contentEl);

    // Divider: Filters (case sensitivity applies here)
    const divider = contentEl.createEl("hr");
    divider.style.marginTop = "12px";

    // Filters: file
    this.makeAddableFilterRow(
      contentEl,
      "file (File name — AND)",
      "e.g., 2025-09 or *.md",
      (v) => this.addChip(this.filePatterns, v),
      () => this.filePatterns
    );

    // Filters: path
    this.makeAddableFilterRow(
      contentEl,
      "path (Path — AND)",
      "e.g., notes/project or */daily/*",
      (v) => this.addChip(this.pathPatterns, v),
      () => this.pathPatterns
    );

    // Filters: tag
    this.makeAddableFilterRow(
      contentEl,
      "tag (Tag — AND)",
      "e.g., project or #project",
      (v) => {
        const tag = v.startsWith("#") ? v.slice(1) : v;
        this.addChip(this.tagFilters, tag);
      },
      () => this.tagFilters
    );

    // Filters: content
    this.makeAddableFilterRow(
      contentEl,
      "content (Body contains — AND)",
      "e.g., endpoint or /end.*point/i",
      (v) => this.addChip(this.contentPatterns, v),
      () => this.contentPatterns
    );

    // Filters: line (same line must contain ALL terms — AND)
    this.makeLineRow(contentEl);

    // Filters: headings (was section)
    this.makeAddableFilterRow(
      contentEl,
      "headings (Heading text — AND)",
      "e.g., Overview or /Chapter\\d+/",
      (v) => this.addChip(this.headingPatterns, v),
      () => this.headingPatterns
    );

    // Filters: property (frontmatter)
    this.makePropertyRow(contentEl);

    // Filter options (case sensitivity, sort, limit)
    this.makeFilterOptionsRow(contentEl);

    // Run
    const buttonRow = contentEl.createEl("div");
    buttonRow.style.marginTop = "12px";
    const runBtn = buttonRow.createEl("button", { text: "Run Search" });
    runBtn.onclick = () => this.submit();
  }

  onClose() {
    this.contentEl.empty();
  }

  // Global Query section (mode and targets)
  private makeGlobalQuerySection(parent: HTMLElement) {
    const wrap = parent.createEl("div");
    wrap.style.marginTop = "8px";

    const title = wrap.createEl("div", { text: "Global Query (applies across selected vault fields)" });
    title.addClass("setting-item-name");

    // Input
    this.globalQueryInputEl = this.makeTextRow(
      wrap,
      "Query (fuzzy/simple/regex)",
      "e.g., quick brown",
      null
    );

    // Mode (affects Global Query)
    const modeRow = wrap.createEl("div");
    modeRow.style.display = "flex";
    modeRow.style.alignItems = "center";
    modeRow.style.gap = "8px";
    modeRow.style.marginTop = "8px";

    modeRow.createEl("label", { text: "Mode (Global Query only)" });
    this.modeSelect = modeRow.createEl("select");
    this.modeSelect.createEl("option", { text: "simple (space-separated AND)", value: "simple" });
    this.modeSelect.createEl("option", { text: "fuzzy (Obsidian fuzzy)", value: "fuzzy" });
    this.modeSelect.createEl("option", { text: "regex (regular expression)", value: "regex" });
    this.modeSelect.value = "simple";

    // Clarification note for case sensitivity and regex behavior.
    const note = wrap.createEl("div");
    note.addClass("setting-item-description");
    note.style.marginTop = "6px";
    note.setText(
      "Note: Case sensitivity checkbox applies to filters only. Global Query ignores case sensitivity except for explicit regex flags. In regex mode, if you do not specify /.../flags, the default is case-insensitive (i)."
    );

    // Targets (vault-wide)
    const targetsTitle = wrap.createEl("div", { text: "Global Query targets (vault-wide)" });
    targetsTitle.addClass("setting-item-name");
    targetsTitle.style.marginTop = "8px";

    const grid = wrap.createEl("div");
    grid.style.display = "grid";
    grid.style.gridTemplateColumns = "repeat(auto-fit, minmax(180px, 1fr))";
    grid.style.gap = "6px";
    grid.style.marginTop = "6px";

    const makeCheckbox = (labelText: string): HTMLInputElement => {
      const container = grid.createEl("label");
      container.style.display = "flex";
      container.style.alignItems = "center";
      container.style.gap = "6px";
      const cb = container.createEl("input", { type: "checkbox" });
      cb.checked = true; // default ON
      container.createEl("span", { text: labelText });
      return cb;
    };

    const body = makeCheckbox("Body");
    const name = makeCheckbox("File name");
    const path = makeCheckbox("Path");
    const fm = makeCheckbox("Frontmatter (keys and values)");
    const tags = makeCheckbox("Tags");
    const headings = makeCheckbox("Headings");

    this.gqTargetCheckboxes = {
      body,
      name,
      path,
      frontmatter: fm,
      tags,
      headings,
    };
  }

  // Utility: simple one-line text row
  private makeTextRow(parent: HTMLElement, label: string, placeholder: string, onEnter: (() => void) | null): HTMLInputElement {
    const row = parent.createEl("div");
    row.style.display = "flex";
    row.style.alignItems = "center";
    row.style.gap = "8px";
    row.style.marginTop = "8px";

    row.createEl("label", { text: label, cls: "setting-item-name" });
    const inputEl = row.createEl("input", { type: "text", placeholder });
    inputEl.style.flex = "1 1 auto";

    if (onEnter) {
      inputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") onEnter();
      });
    }
    return inputEl;
  }

  // Utility: add chip to array and refresh
  private addChip(arr: string[], v: string) {
    const val = v.trim();
    if (!val) {
      new Notice("Value is empty.");
      return;
    }
    arr.push(val);
    this.requestChipRefresh?.();
  }

  // Shared chip refresh hook
  private requestChipRefresh: (() => void) | null = null;

  private makeAddableFilterRow(
    parent: HTMLElement,
    label: string,
    placeholder: string,
    onAdd: (value: string) => void,
    getList: () => string[]
  ) {
    const wrap = parent.createEl("div");
    wrap.style.marginTop = "8px";

    const title = wrap.createEl("div", { text: label });
    title.addClass("setting-item-name");

    const row = wrap.createEl("div");
    row.style.display = "flex";
    row.style.alignItems = "center";
    row.style.gap = "8px";

    const inputEl = row.createEl("input", { type: "text", placeholder });
    inputEl.style.flex = "1 1 auto";

    const addBtn = row.createEl("button", { text: "+" });
    addBtn.onclick = () => onAdd(inputEl.value);

    inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") onAdd(inputEl.value);
    });

    const chipsEl = wrap.createEl("div");
    chipsEl.style.display = "flex";
    chipsEl.style.flexWrap = "wrap";
    chipsEl.style.gap = "6px";
    chipsEl.style.marginTop = "6px";

    const refresh = () => {
      chipsEl.empty();
      const list = getList();
      list.forEach((v, idx) => {
        const chip = chipsEl.createEl("span", { text: v });
        chip.style.border = "1px solid var(--background-modifier-border)";
        chip.style.borderRadius = "12px";
        chip.style.padding = "2px 8px";
        chip.style.display = "inline-flex";
        chip.style.alignItems = "center";
        chip.style.gap = "6px";

        const del = chip.createEl("button", { text: "×" });
        del.style.marginLeft = "6px";
        del.onclick = () => {
          list.splice(idx, 1);
          refresh();
        };
      });
    };

    const prev = this.requestChipRefresh;
    this.requestChipRefresh = () => {
      prev?.();
      refresh();
    };
    refresh();
  }

  // line: same line must contain ALL terms (AND). Terms added as chips; internally combined via lookahead regex.
  private makeLineRow(parent: HTMLElement) {
    const wrap = parent.createEl("div");
    wrap.style.marginTop = "8px";

    const title = wrap.createEl("div", { text: "line (terms that must appear on the same line — AND)" });
    title.addClass("setting-item-name");

    const row = wrap.createEl("div");
    row.style.display = "flex";
    row.style.alignItems = "center";
    row.style.gap = "8px";

    const inputEl = row.createEl("input", {
      type: "text",
      placeholder: 'e.g., har or "error 500". Space-separated input adds multiple terms at once.',
    });
    inputEl.style.flex = "1 1 auto";

    const addBtn = row.createEl("button", { text: "+" });
    addBtn.onclick = () => {
      const val = inputEl.value.trim();
      if (!val) {
        new Notice("Value is empty.");
        return;
      }
      const terms = tokenizeWithQuotes(val).filter(Boolean);
      if (terms.length === 0) {
        new Notice("No valid terms.");
        return;
      }
      for (const t of terms) {
        if (!this.lineTerms.includes(t)) this.lineTerms.push(t);
      }
      refresh();
    };

    inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") addBtn.onclick?.(null as any);
    });

    const chipsEl = wrap.createEl("div");
    chipsEl.style.display = "flex";
    chipsEl.style.flexWrap = "wrap";
    chipsEl.style.gap = "6px";
    chipsEl.style.marginTop = "6px";

    const refresh = () => {
      chipsEl.empty();
      this.lineTerms.forEach((term, idx) => {
        const chip = chipsEl.createEl("span", { text: term });
        chip.style.border = "1px solid var(--background-modifier-border)";
        chip.style.borderRadius = "12px";
        chip.style.padding = "2px 8px";
        chip.style.display = "inline-flex";
        chip.style.alignItems = "center";
        chip.style.gap = "6px";

        const del = chip.createEl("button", { text: "×" });
        del.style.marginLeft = "6px";
        del.onclick = () => {
          this.lineTerms.splice(idx, 1);
          refresh();
        };
      });
    };
    refresh();
  }

  // property: name + value(optional)
  private makePropertyRow(parent: HTMLElement) {
    const wrap = parent.createEl("div");
    wrap.style.marginTop = "8px";

    const title = wrap.createEl("div", { text: "property (Frontmatter — AND)" });
    title.addClass("setting-item-name");

    const row = wrap.createEl("div");
    row.style.display = "flex";
    row.style.alignItems = "center";
    row.style.gap = "8px";

    const nameEl = row.createEl("input", { type: "text", placeholder: "Property name (e.g., status)" });
    const valueEl = row.createEl("input", { type: "text", placeholder: "Value (e.g., done or /d(?!one)/i)" });

    nameEl.style.flex = "0 0 160px";
    valueEl.style.flex = "1 1 auto";

    const addBtn = row.createEl("button", { text: "+" });
    addBtn.onclick = () => {
      const name = nameEl.value.trim();
      const raw = valueEl.value.trim();
      if (!name) {
        new Notice("Enter a property name.");
        return;
      }
      let v: string | RegExp | null = null;
      if (raw) {
        v = tryParseExplicitRegex(raw) ?? raw;
      } else {
        v = null; // existence check
      }
      this.propertyFilters.push({ name, value: v });
      refresh();
    };

    nameEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") addBtn.onclick?.(null as any);
    });
    valueEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") addBtn.onclick?.(null as any);
    });

    const chipsEl = wrap.createEl("div");
    chipsEl.style.display = "flex";
    chipsEl.style.flexWrap = "wrap";
    chipsEl.style.gap = "6px";
    chipsEl.style.marginTop = "6px";

    const refresh = () => {
      chipsEl.empty();
      this.propertyFilters.forEach((pf, idx) => {
        const valStr =
          pf.value === null
            ? "(exists)"
            : pf.value instanceof RegExp
            ? `/${pf.value.source}/${pf.value.flags}`
            : String(pf.value);
        const label = `${pf.name}:${valStr}`;
        const chip = chipsEl.createEl("span", { text: label });
        chip.style.border = "1px solid var(--background-modifier-border)";
        chip.style.borderRadius = "12px";
        chip.style.padding = "2px 8px";
        chip.style.display = "inline-flex";
        chip.style.alignItems = "center";
        chip.style.gap = "6px";

        const del = chip.createEl("button", { text: "×" });
        del.style.marginLeft = "6px";
        del.onclick = () => {
          this.propertyFilters.splice(idx, 1);
          refresh();
        };
      });
    };
    refresh();
  }

  // Filter options: case sensitivity, sort, limit
  private makeFilterOptionsRow(parent: HTMLElement) {
    const row = parent.createEl("div");
    row.style.display = "grid";
    row.style.gridTemplateColumns = "repeat(auto-fit, minmax(220px, 1fr))";
    row.style.gap = "8px";
    row.style.marginTop = "12px";

    // Case sensitivity (filters only)
    {
      const cell = row.createEl("div");
      const label = cell.createEl("label");
      this.csCheckbox = cell.createEl("input", { type: "checkbox" });
      this.csCheckbox.style.marginRight = "6px";
      label.appendChild(this.csCheckbox);
      label.appendText("Case sensitive (filters only)");
    }

    // Sort
    {
      const cell = row.createEl("div");
      const label = cell.createEl("label", { text: "Sort" });
      this.sortSelect = cell.createEl("select");
      this.sortSelect.createEl("option", { text: "Modified time (newest first)", value: "mtime-desc" });
      this.sortSelect.createEl("option", { text: "Modified time (oldest first)", value: "mtime-asc" });
      this.sortSelect.createEl("option", { text: "Path (ascending)", value: "path-asc" });
      this.sortSelect.value = "mtime-desc";
    }

    // Limit
    {
      const cell = row.createEl("div");
      cell.createEl("label", { text: "Max results (leave empty for no limit)" });
      this.limitInput = cell.createEl("input", { type: "number", placeholder: "e.g., 100" });
      this.limitInput.min = "1";
    }
  }

  private submit() {
    const caseSensitive = !!this.csCheckbox.checked;

    // lineTerms -> single lookahead regex literal
    const linePatternLiteral =
      this.lineTerms.length > 0 ? buildLineRegexLiteral_AND(this.lineTerms, caseSensitive) : null;

    const p: ParsedQuery = {
      globalQuery: this.globalQueryInputEl.value.trim(),
      filePatterns: [...this.filePatterns],
      pathPatterns: [...this.pathPatterns],
      tagFilters: [...this.tagFilters],
      contentPatterns: [...this.contentPatterns],
      linePatterns: linePatternLiteral ? [linePatternLiteral] : [],
      headingPatterns: [...this.headingPatterns],
      propertyFilters: [...this.propertyFilters],
    };

    const options: SearchOptions = {
      mode: (this.modeSelect.value as SearchMode) ?? "simple",
      caseSensitive, // filters only
      sort: (this.sortSelect.value as SortMode) ?? "mtime-desc",
      limit: this.limitInput.value.trim() ? Math.max(1, Number(this.limitInput.value.trim())) : null,
      globalQueryTargets: {
        body: !!this.gqTargetCheckboxes?.body.checked,
        name: !!this.gqTargetCheckboxes?.name.checked,
        path: !!this.gqTargetCheckboxes?.path.checked,
        frontmatter: !!this.gqTargetCheckboxes?.frontmatter.checked,
        tags: !!this.gqTargetCheckboxes?.tags.checked,
        headings: !!this.gqTargetCheckboxes?.headings.checked,
      },
    };

    if (
      !p.globalQuery &&
      !p.filePatterns.length &&
      !p.pathPatterns.length &&
      !p.tagFilters.length &&
      !p.contentPatterns.length &&
      !p.linePatterns.length &&
      !p.headingPatterns.length &&
      !p.propertyFilters.length
    ) {
      new Notice("No filters specified. Please add at least one.");
      return;
    }

    this.onSubmit(p, options, { lineTerms: [...this.lineTerms] });
    this.close();
  }
}
```